#!/bin/bash
# tm - tmux session manager TUI
# One command to see, attach, and kill sessions with CPU + RAM visibility

set -e

# Colors
RED='\033[0;31m'
YELLOW='\033[0;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
DIM='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Collect pane PIDs + their direct children as comma-separated string for ps -p
# Iterates per-window to avoid counting shared windows from linked sessions
# Input: tmux session name
# Output: comma-separated PID list
collect_pids_csv() {
    local session="$1"
    local csv=""
    while read -r win_idx; do
        while read -r pid; do
            [ -z "$pid" ] && continue
            csv="${csv:+$csv,}$pid"
            while read -r child; do
                csv="${csv:+$csv,}$child"
            done < <(pgrep -P "$pid" 2>/dev/null)
        done < <(tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null)
    done < <(tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null)
    echo "$csv"
}

# Kill all processes in a tmux session (iterates per-window to avoid shared windows)
kill_session_processes() {
    local session="$1"
    while read -r win_idx; do
        while read -r pid; do
            pkill -TERM -P "$pid" 2>/dev/null || true
            sleep 0.1
            pkill -KILL -P "$pid" 2>/dev/null || true
        done < <(tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null)
    done < <(tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null)
    tmux kill-session -t "$session" 2>/dev/null
}

# Get session info with CPU + RAM
get_session_info() {
    local session="$1"
    local windows=$(tmux list-windows -t "$session" 2>/dev/null | wc -l | tr -d ' ')
    local attached=$(tmux list-sessions -F "#{session_name} #{?session_attached,ATTACHED,detached}" 2>/dev/null | grep "^$session " | awk '{print $2}')

    local pids_csv=$(collect_pids_csv "$session")
    local total_cpu="0"
    local total_ram="0"
    local top_proc=""

    if [ -n "$pids_csv" ]; then
        local stats=$(ps -p "$pids_csv" -o %cpu=,rss=,comm= 2>/dev/null)
        if [ -n "$stats" ]; then
            total_cpu=$(echo "$stats" | awk '{sum+=$1} END {printf "%.0f", sum}')
            total_ram=$(echo "$stats" | awk '{sum+=$2} END {printf "%.0f", sum/1024}')
            top_proc=$(echo "$stats" | sort -rn -k2 | head -1 | awk '{print $3}')
        fi
    fi

    local status_color=""
    if [ "$attached" = "ATTACHED" ]; then
        status_color="$GREEN"
    else
        status_color="$DIM"
    fi

    local ram_color="$NC"
    if [ "${total_ram:-0}" -gt 1000 ]; then
        ram_color="$RED"
    elif [ "${total_ram:-0}" -gt 500 ]; then
        ram_color="$YELLOW"
    fi

    local cpu_color="$NC"
    if [ "${total_cpu:-0}" -gt 50 ]; then
        cpu_color="$RED"
    elif [ "${total_cpu:-0}" -gt 10 ]; then
        cpu_color="$YELLOW"
    fi

    printf "%-15s %2s wins  ${status_color}%-10s${NC}  ${ram_color}%6sMB${NC}  ${cpu_color}%4s%%${NC}  ${DIM}%s${NC}" \
        "$session" "$windows" "$attached" "${total_ram:-0}" "${total_cpu:-0}" "$top_proc"
}

# Main TUI
main() {
    if ! tmux list-sessions &>/dev/null; then
        echo "No tmux sessions running."
        exit 0
    fi

    # Build session list
    local session_list=""
    while read -r session; do
        session_list+="$(get_session_info "$session")\n"
    done < <(tmux list-sessions -F "#{session_name}" 2>/dev/null)

    # Create temp script for preview (per-window resource breakdown)
    local preview_script=$(mktemp)
    cat > "$preview_script" << 'PREVIEW'
#!/bin/bash
session=$(echo "$1" | awk '{print $1}')
RED='\033[0;31m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
DIM='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

window_data=""
total_session_ram=0
total_session_cpu=0

while IFS=$'\t' read -r win_idx win_name _; do
    # Collect PIDs for this window as comma-separated
    pids_csv=""
    while read -r pid; do
        [ -z "$pid" ] && continue
        pids_csv="${pids_csv:+$pids_csv,}$pid"
        while read -r child; do
            pids_csv="${pids_csv:+$pids_csv,}$child"
        done < <(pgrep -P "$pid" 2>/dev/null)
    done < <(tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null)

    win_ram=0
    win_cpu=0
    procs=""

    if [ -n "$pids_csv" ]; then
        while read -r cpu rss comm; do
            [ -z "$cpu" ] && continue
            rss_mb=$(( (rss + 512) / 1024 ))
            win_ram=$((win_ram + rss_mb))
            win_cpu=$(echo "$win_cpu + $cpu" | bc -l 2>/dev/null || echo "$win_cpu")
            if [ "$rss_mb" -gt 1 ]; then
                base=$(basename "$comm" 2>/dev/null || echo "$comm")
                procs="${procs}${base}(${rss_mb}MB) "
            fi
        done < <(ps -p "$pids_csv" -o %cpu=,rss=,comm= 2>/dev/null)
    fi

    total_session_ram=$((total_session_ram + win_ram))
    total_session_cpu=$(echo "$total_session_cpu + $win_cpu" | bc -l 2>/dev/null || echo "$total_session_cpu")

    win_cpu_fmt=$(printf "%.1f" "$win_cpu" 2>/dev/null || echo "0.0")
    window_data="${window_data}${win_ram}|${win_cpu_fmt}|${win_idx}|${win_name}|${procs}\n"

done < <(tmux list-windows -t "$session" -F "#{window_index}	#{window_name}	#{window_panes}" 2>/dev/null)

# Header
total_cpu_fmt=$(printf "%.0f" "$total_session_cpu" 2>/dev/null || echo "0")
echo -e "${BOLD}${BLUE}$session${NC}  ${DIM}(${total_session_ram} MB, ${total_cpu_fmt}% CPU)${NC}\n"

# Print windows sorted by RAM (highest first)
echo -e "$window_data" | grep -v '^$' | sort -t'|' -k1 -rn | while IFS='|' read -r ram cpu idx name procs; do
    [ -z "$idx" ] && continue

    if [ "$ram" -gt 100 ]; then
        ram_c="$RED"
    elif [ "$ram" -gt 30 ]; then
        ram_c="$YELLOW"
    else
        ram_c="$DIM"
    fi

    cpu_int=${cpu%.*}
    if [ "${cpu_int:-0}" -gt 10 ]; then
        cpu_c="$YELLOW"
    else
        cpu_c="$DIM"
    fi

    if [ ${#procs} -gt 40 ]; then
        procs="${procs:0:37}..."
    fi

    printf "  ${BOLD}#%-2s${NC} %-14s ${ram_c}%5s MB${NC}  ${cpu_c}%5s%%${NC}  ${DIM}%s${NC}\n" \
        "$idx" "$name" "$ram" "$cpu" "$procs"
done
PREVIEW
    chmod +x "$preview_script"

    # Create temp script for kill action
    local kill_script=$(mktemp)
    cat > "$kill_script" << 'KILL'
#!/bin/bash
session=$(echo "$1" | awk '{print $1}')
while read -r win_idx; do
    while read -r pid; do
        pkill -TERM -P "$pid" 2>/dev/null || true
        sleep 0.1
        pkill -KILL -P "$pid" 2>/dev/null || true
    done < <(tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null)
done < <(tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null)
tmux kill-session -t "$session" 2>/dev/null
KILL
    chmod +x "$kill_script"

    # Create temp script for kill-all-detached
    local killall_script=$(mktemp)
    cat > "$killall_script" << 'KILLALL'
#!/bin/bash
detached=$(tmux list-sessions -F "#{session_name} #{?session_attached,attached,detached}" 2>/dev/null | grep "detached" | awk '{print $1}')
for session in $detached; do
    while read -r win_idx; do
        while read -r pid; do
            pkill -TERM -P "$pid" 2>/dev/null || true
            sleep 0.1
            pkill -KILL -P "$pid" 2>/dev/null || true
        done < <(tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null)
    done < <(tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null)
    tmux kill-session -t "$session" 2>/dev/null
done
KILLALL
    chmod +x "$killall_script"

    # Create temp script for reload (regenerates session list)
    local reload_script=$(mktemp)
    cat > "$reload_script" << 'RELOAD'
#!/bin/bash
RED='\033[0;31m'
YELLOW='\033[0;33m'
GREEN='\033[0;32m'
DIM='\033[0;90m'
NC='\033[0m'

while read -r session; do
    windows=$(tmux list-windows -t "$session" 2>/dev/null | wc -l | tr -d ' ')
    attached=$(tmux list-sessions -F "#{session_name} #{?session_attached,ATTACHED,detached}" 2>/dev/null | grep "^$session " | awk '{print $2}')

    # Collect PIDs as CSV (per-window to avoid shared windows)
    pids_csv=""
    while read -r win_idx; do
        while read -r pid; do
            [ -z "$pid" ] && continue
            pids_csv="${pids_csv:+$pids_csv,}$pid"
            while read -r child; do
                pids_csv="${pids_csv:+$pids_csv,}$child"
            done < <(pgrep -P "$pid" 2>/dev/null)
        done < <(tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null)
    done < <(tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null)

    total_cpu="0"
    total_ram="0"
    top_proc=""

    if [ -n "$pids_csv" ]; then
        stats=$(ps -p "$pids_csv" -o %cpu=,rss=,comm= 2>/dev/null)
        if [ -n "$stats" ]; then
            total_cpu=$(echo "$stats" | awk '{sum+=$1} END {printf "%.0f", sum}')
            total_ram=$(echo "$stats" | awk '{sum+=$2} END {printf "%.0f", sum/1024}')
            top_proc=$(echo "$stats" | sort -rn -k2 | head -1 | awk '{print $3}')
        fi
    fi

    if [ "$attached" = "ATTACHED" ]; then
        status_color="$GREEN"
    else
        status_color="$DIM"
    fi

    ram_color="$NC"
    if [ "${total_ram:-0}" -gt 1000 ]; then
        ram_color="$RED"
    elif [ "${total_ram:-0}" -gt 500 ]; then
        ram_color="$YELLOW"
    fi

    cpu_color="$NC"
    if [ "${total_cpu:-0}" -gt 50 ]; then
        cpu_color="$RED"
    elif [ "${total_cpu:-0}" -gt 10 ]; then
        cpu_color="$YELLOW"
    fi

    printf "%-15s %2s wins  ${status_color}%-10s${NC}  ${ram_color}%6sMB${NC}  ${cpu_color}%4s%%${NC}  ${DIM}%s${NC}\n" \
        "$session" "$windows" "$attached" "${total_ram:-0}" "${total_cpu:-0}" "$top_proc"
done < <(tmux list-sessions -F "#{session_name}" 2>/dev/null)
RELOAD
    chmod +x "$reload_script"

    # Temp file for Ctrl-n (new session name)
    local newname_file=$(mktemp)
    rm -f "$newname_file"

    # Header
    local header="Enter: attach │ Ctrl-n: new session │ Ctrl-k: kill │ Ctrl-x: kill detached │ Esc: exit"

    # Run fzf
    local selected=$(echo -e "$session_list" | grep -v '^$' | \
        fzf --ansi \
            --header="$header" \
            --preview="$preview_script {}" \
            --preview-window=right:55%:wrap \
            --bind="ctrl-k:execute-silent($kill_script {})+reload($reload_script)" \
            --bind="ctrl-x:execute-silent($killall_script)+reload($reload_script)" \
            --bind="ctrl-n:execute-silent(echo {q} > $newname_file)+abort" \
            --no-multi \
            --height=80% \
            --layout=reverse \
            --border=rounded \
            --prompt="tmux> " \
            --pointer="▶" \
            --color="header:italic:dim") || true

    # Cleanup temp scripts
    rm -f "$preview_script" "$kill_script" "$killall_script" "$reload_script"

    # Ctrl-n: create new session from query
    if [ -f "$newname_file" ]; then
        local name=$(cat "$newname_file" | tr -cs 'a-zA-Z0-9_-' '-' | sed 's/^-//;s/-$//')
        rm -f "$newname_file"
        if [ -z "$name" ]; then
            echo "Invalid session name"
            exit 1
        fi
        if tmux has-session -t "$name" 2>/dev/null; then
            echo "Session '$name' already exists"
            exit 1
        fi
        if [ -n "$TMUX" ]; then
            tmux new-session -d -s "$name"
            tmux switch-client -t "$name"
        else
            tmux new-session -s "$name"
        fi
        exit 0
    fi

    # Normal selection — attach to session
    if [ -n "$selected" ]; then
        local session=$(echo "$selected" | awk '{print $1}')
        if tmux has-session -t "$session" 2>/dev/null; then
            tmux switch-client -t "$session" 2>/dev/null || tmux attach-session -t "$session"
        fi
    fi
}

# Handle --info flag for reload
if [ "$1" = "--info" ] && [ -n "$2" ]; then
    get_session_info "$2"
    exit 0
fi

# Direct switch: tm <session-name>
if [ -n "$1" ]; then
    session="$1"
    if tmux has-session -t "$session" 2>/dev/null; then
        tmux switch-client -t "$session" 2>/dev/null || tmux attach-session -t "$session"
    else
        if [ -n "$TMUX" ]; then
            tmux new-session -d -s "$session"
            tmux switch-client -t "$session"
        else
            tmux new-session -s "$session"
        fi
    fi
    exit 0
fi

main
